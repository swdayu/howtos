
## 文法的乔姆斯基体系

文法G是一个四元组`G = (V, T, P, S)`，其中V是非终结符（也称为语法变量）集合，T是终结符集合，P是产生式集合，而S是起始符号（属于集合V），则：

一、如果文法的所有产生式均具有如下形式（其中A和B属于V是语法变量，w属于T是对应字符集上的终结符号）
```c
A -> w
A -> wB
```
那么称G为正则文法（Regular Grammar, RG），对应地根据该文法形成的语言L(G)称为正则语言（RL）。

二、如果所有产生式都满足（其中A是语法变量，β是非终结符和终结符形成的序列）
```c
A -> β
```
且β的长度（其中非终结符和终结符的个数）|β|大于等于1，那么称G为上下文无关文法（Context Free Grammar, CFG），对应地根据该文法形成的语言L(G)称为上下文无关语言（CFL）。上下文无关文法的含义是，无论语法变量A出现在句型的任何位置，都可以将A替换成β而不用考虑A所处的上下文。它跟下面定义的上下文有关文法的区别是，它的产生式的左边只能是单独的一个语法变量符号，进行替换时可以独立的进行替换。而上下文有关文法不能，它牵扯到周围的语法变量或终结符号，要进行替换，α中的语法变量和终结符号需要一起替换。

三、如果所有产生式都满足（其中α和β都是由非终结符和终结符形成的序列）
```c
α -> β
```
其β的长度总大于等于α的长度`|β|>=|α|`，那么称G为上下文有关文法（Context Sensitive Grammar, CSG），对应地根据该文法形成的语言L(G)称为上下文有关语言（CSL）。

四、如果对文法的产生式不做任何限制，那么称对应的文法G为短语结构文法（Phrase Structure Grammar, PSG），根据该文法形成的语言L(G)称为短语结构语言（PSL）、或递归可枚举集（Recursively Enumerable Set）。

## 上下文无关文法

- http://www.cnblogs.com/Ninputer/archive/2011/06/18/2084383.html
- http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.30.7601

在计算机高级程序设计语言的解析中，正则文法只能对语言的单词组成规则进行描述（词法）。也就是说，正则文法解决的是像标识符如何组成、整数实数如何表示等问题，对于表达式和语句等更复杂的结构，正则表达式没有描述能力。另外经验表明，高级程序设计语言的绝大多数语法结构都可以通过上下文无关文法（CFG）来描述。因此，高级程序设计语言的规范说明及其编译是CFG的一个重要应用领域，而描述高级程序设计语言的巴克斯范式BNF（Backus Normal Form）就是CFG的一种特殊形式。

## 正则表达式的构建
```c
 1. .   点号匹配除换行符(\n)之外的任意单一字符
 2. ^   匹配行首
 3. $   匹配行尾
 4. *   匹配0个或多个
 5. +   匹配1个或多个
 6. ?   匹配0个或1个
 7. |   只要匹配其中之一即匹配成功，例如"a"|"bc"
 8. ()  将匹配表达式组合成一个新的表达式
 9. {n} {n,m} {n,} 匹配n个、n个到m个，大于等于n个，例如("a"|"bc"){8}
10. /   匹配斜杠之前的表达式，但是要求之后的字符串也要匹配斜杠之后的表达式，如"0"/"1"匹配"01"中的0，但不匹配"02"中的0
11. "abc" 匹配对应的字符串
12. ```abc\t\u0A1F``` 匹配对应的原始(没有进行转义的)字符串
13. {Expr} 匹配对应名称的表达式 
14. 字符集合：['0-9' 'a' '\t' '\u0A1F' '\'' ']' '[' '.'] [^ '0' 'A-Z' '^']
15. 字符差集：[]{-}[]，可扩展到表达式匹配差集？{Expr1 - Expr2}
16. 字符并集：[]{+}[]，可扩展到表达式匹配并集？{Expr1 + Expr2}

*每个模式只允许一个尾部上下文操作符，而且一个模式不能既有斜线又有尾部的$
*二义性处理：使用贪婪法尽可能多的匹配输入串；先定义的优先匹配，例如"+"和"+="；
```

## PEG (Parsing Expression Grammars)
```c
n: 匹配n个字符
"abc": 匹配字符a和b和c
Before(Expr): 当前位置之前匹配表达式Expr，不消耗字符
Range("az"), Range("az", "09", "AA", "BC"): 字符范围
Set("abc*/+"): 匹配其中的单一字符
#Expr: 当前位置之后匹配Expr，不消耗字符
-Expr: 只要当不匹配Expr是才匹配成功
Expr1+Expr2: 匹配其中一个表达式即匹配成功
Expr1-Expr2: 只要当不匹配Expr2但匹配Expr1时才匹配成功
Expr1*Expr2: 匹配Expr1并且匹配Expr2是才匹配成功
Expr^n: 匹配n个或多个Expr1
```
