
# InputReader

InputReader的输入端是设备节点，输出端是InputDispatcher的派发队列。
设备节点的新建与删除表示输入设备的可用与无效，InputReader需要加载
或删除对应设备的配置信息；而设备节点中是否有内容可读表示了是否有新
的原始事件到来。问题是应该如何监控设备节点的新建与删除动作以及如何
确定节点中有内容可读呢？最简单的方法是在线程循环中不断的轮询，然而
这会导致非常低下的效率，更会导致电量在无谓的轮询中消耗。Android使用
有Linux提供的两套机制INotify与Epoll优雅地解决了这两个问题。

INotify是Linux内核提供的一种文件系统变化机制，它可以为应用程序监控文件系统的变化，如文件的新建、删除、
读写等。INotify机制有两个基本对象，分别为inotify对象以及watch对象，都是用文件描述符表示。inotify对象
对应一个队列，应用程序可以向inotify对象添加多个监听。当被监听的事件发生时，可以通过read从inotify对象
中将事件信息读取。Inotify对象可以通过`int ifd = inotify_init()`方式创建。而watch对象则用于表示监听。
它是一个二元组，包括监听目标和事件掩码两个元素。监听目标是文件系统的一个路径，可以是文件也可以是文件
夹。而事件掩码则表示了需要监听的事件的类型，掩码中的每一位代表一种事件。可以监听的事件种类很多，其中
就包括文件的创建（IN_CREATE）与删除（IN_DELETE）。以下代码即可将一个用于监听输入设备节点创建和删除
的watch对象添加到inotify对象中`inotify_add_watch(ifd, "/dev/input", IN_CREATE|IN_DELETE)`。
注意INotify机制并不是通过回调的方式通知事件，而需要使用者主动从inotify对象中进行事件读取。那何时才是
读取的最佳时机呢？这就需要借助Linux的另一优秀机制Epoll了。

无论是从设备节点中获取原始输入事件还是从inotify对象中获取文件系统事件，都面临一个问题，就是这些事件都是
偶发的。也就是说，大部分情况下设备节点、inotify对象这些文件描述符中都是无数据可读的，同事又希望有事件到
来时可以尽快地对事件做出反应。为解决这个问题，我们不希望不断的轮询这些描述符，也不希望为每个描述符创建
一个单独的线程进行阻塞式读取，因为这都会导致资源极大浪费。此时最佳的办法是使用Epoll机制，Epoll可以使用
一次等待监听多个描述符的可读/可写状态。等待返回是携带了可读的描述符或自定义的数据，使用者据此读取所需的
数据后可以再次进入等待。因此不需要为每个描述符创建独立的线程进行阻塞读取，避免了资源浪费的同时又可以获得
较快的响应速度。

Epoll机制的接口只有三个函数，十分简单。epoll_create(max_fds)创建epoll对象的描述符，max_fds参数表示此
epoll对象可以监听的描述符的最大数量。epoll_ctl(epfd, op, fd, *event)用于添加/删除/修改要监听的描述符。
epoll_wait(epfd, *events, maxevents, timeout)用于等待事件到来，当此函数返回时，events数组中将会包含
产生事件的文件描述符。


## 基本流程

InputReader被InputManager创建后就运行于InputReaderThread线程中。InputReader的一次线程循环的工作非常清晰，
一共三步：首先从EventHub中抽取未处理的事件列表，这些事件分为两类，一类是从设备节点中读取原始输入事件，另一
类则是输入设备可用性变化事件，成为设备事件；通过processEventsLocked对事件进行处理，对于设备事件此函数根据
设备的可用性加载或删除设备对应的配置信息。对于原始输入事件，则在转译、封装与加工后将结果暂存到mQueueLinstener中；
所有事件处理完毕后，调用mQueueListener.flush将所有暂存的输入事件一次性地交付给InputDispatcher。

EventHub是输入系统最底层的一个组件，它基于INotify和Epoll实现。在EventHub的构造函数中，通过INotify与Epoll
机制建立起对设备节点增删事件以及可读状态的监听。
