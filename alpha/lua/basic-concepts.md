
# 元表和元函数

Lua中的每个值都可以有一个元表，这个table用于定义值对应的特定操作的行为。
可以设置这个table的内容来改变特定操作的某些行为。
例如对非数值型值执行加操作，Lua会查找这个table中"__add"域对应的值（一个函数），
如果找到则调用这个函数执行加操作。这里键"__add"表示特定的操作，其对应的值称为元函数。
可以调用函数getmetable获取值的元表，也可以调用函数setmetatable为值设置一个新元表。
元表只能在C API函数中修改，Lua代码是不能修改元表的。
设置元表的元函数的推荐做法是先添加好所有的元函数到一个table中，然后一次将这个元表设置到对应的对象中。
特别地，"__gc"元函数只能用这个方法设置才能生效。

表（tables）和完全用户数据（full userdata）拥有独立的元表，但也可以共享。
而其他类型的值都共享一个对应类型的元表，即所有数值共享数值类型的元表，所有字符串共享字符串类型的元表。
元表用于控制一个对象算术运算、位运算、关系运算、连接、长度操作、调用、和索引的行为。
元表还能为表和用户数据定义一个函数在垃圾回收时调用。
对于一元操作（如取负、长度操作、位反），第2个操作数是一个哑数据，其值与第1个操作数相等。
这个额外的操作数仅为了简化Lua的内部实现，可以会在将来的版本中移除。

Lua中的元函数列举如下：
- "\__add" (+): 只要有一个操作数不是数值（也不是能转换成数值的字符串），Lua会依次尝试第1个操作数和第2个操作数的add元函数，如果失败则抛出错误
- "\__sub/mul/div/mod/pow" (- * / % ^), "\__unm" (- unary minus), "\__idiv" (// floor div): 与add操作类似
- "\__band/bor/bxor/bnot/shl/shr" (& | ~ ~ << >>): 只要有一个操作数不是整数（也不是能转换成整数的值），Lua就会尝试元函数
- "\__concat" (..): 只要有一个操作数不是字符串或数值，Lua就会尝试元函数
- "\__len" (#): 如果操作数不是字符串和表（table），Lua就会尝试元函数
- "\__eq" (==): 与add操作类似，但只有两个操作数都是表或都是完全用户数据并且内部表示的地址不相等时才尝试元函数
- "\__lt" (<): 与add操作类似。TODO 两个字符串怎么办？一个数值和一个不能转换成数值的字符串怎么办？__eq的情况呢？
- "\__le" (<=): Lua在尝试元函数时，如果le元函数没有找到，会尝试lt元函数（因为 a <= b 相当于 !(b < a)）
- "\__index" (table[key]): 当对象不是table或key不是table的键时，Lua会尝试元函数；这个元函数的值可以是一个函数或一个table
- "\__newindex" (table[key] = value): 与index操作类似
- "\__call" (func(args)): 当对象不是函数时，Lua会尝试元函数，传入func作为第1个参数，后面跟实际的参数args
- "\__gc": 可以为表和完全用户数据设置垃圾收集元函数，这些元函数也称为finalizers，允许垃圾收集时一起释放其他资源（如文件、网络或数据库连接、你自己的内存等）
- "\__mode": 设置表在的键是否都是弱键或弱值

# 垃圾收集

## 弱表

弱表中的元素都是弱引用，弱引用会被垃圾收集器忽略不计，即当对象的引用都是弱引用时，垃圾收集其会将这个对象回收。
弱表可以有弱键、弱值、或两者都有，可以通过元函数"__mode"来进行设置。
设置包含字符'k'的字符串表示这个表中的键都是弱键，如果包含字符'v'表示这个表中的值都是弱值。

TODO
