
ECS模型是一种以属性为中心的软件架构风格，主要用于游戏开发中。该模型由三个主要部分组成，
实体（Entity）表示一个游戏对象，通常只包含一个表示对象ID的唯一标识符，实体通过集合不同
类型的组件（Component）来构成特定类型的游戏对象，另外实体也可用来作为属性间通信的枢纽。
组件表示一个属性的数据部分，例如HealthComponent表示血量属性的数据，组件除了一些方便的
get/set外，通常不包含内部数据处理方法。系统（System）表示属性的行为部分，例如
HealthSystem会检测血量属性值并在血量小于或等于0时向实体发出通知。系统通常由游戏循环驱
动来修改游戏对象的状态，包含一个update方法。所以，一个属性由组件和系统构成，分别表示
属性的数据和行为。

在ECS模型中，组件和系统几乎是一一对应的，但也有可能某些属性只包含数据而没有系统实例与
它对应。组件和系统分开的设计使得数据和行为分离，数据和逻辑高度解耦，让数据更容易管理和
优化。ECS模型还易于添加和删除组件，适应快速变化的需求。ECS模式遵循组合优于继承的思想，
采用类似数据库的结构来存储对象，能够实现高度的数据驱动。

总体来说，一个实体包含多个属性，本质上是属性的容器，每个属性通过组件和系统进行描述。组
件描述的是游戏所需的所有数据结构。系统是纯方法组合，它自己没有内部状态，它要么做成无副
作用的纯函数，根据它所能见到的对象组件组合计算出某种结果，要么用来更新特定组件的状态。

实体可以理解为标识一个对象，它没有任何具体的数据和行为，只是标识一个东西。在实现上，通
常用一个结构体来实现，而组件为其提供数据。一个组件相当于一种固定的数据结构，这个数据结
构有什么行为可以通过不同的系统进行解释。

例如拥有移动属性的实体，可以进行移动，该属性对应的组件描述移动属性的相关数据，而处理移
动的系统仅仅关心拥有移动能力的实体，它会遍历所有拥有移动组件的实体，并根据相关的数据
（速度、位置、朝向等），更新实体的位置。实体与组件是一个一对多的关系，实体拥有怎样的能
力，完全取决于其拥有哪些组件，通过动态添加或删除组件，可以在游戏运行时改变实体的行为。
组件的例子，Seeing、Living、Moving、Hopping、Flying。

游戏世界它是系统和实体的集合，而实体就是一个ID，这个ID对应了一个组件集合。组件用来存储
游戏状态并且没有任何行为，系统拥有处理实体的行为但没有状态。

一个经典的游戏主循环一般会包括几个最主要的部分：渲染循环负责更新每一帧用户会看到的东西，
比如提及GPU需要的数据（顶点属性、相机等），更新动画，更新粒子引擎等等；物理循环负责更新
物理逻辑，比如碰撞检测，力学模拟等等；逻辑循环赋值游戏逻辑，通常游戏引擎都会由分离的逻
辑层和渲染层，渲染层靠逻辑层来驱动，比如播放动画、角色移动、跳跃、战斗等等。

为了让逻辑层和渲染层以不同的帧率运行，实际上大部分游戏都是这么做的，我们可以把逻辑层单
独抽出来用独立的逻辑线程跑，逻辑层和其他层通过消息机制来交互。为了保证物理和渲染的同步
性，渲染线程每一帧都需要在帧末尾同步物理模拟结果。

在游戏运行过程中，逻辑层和渲染层采用不同的帧率，主要是为了在游戏的稳定性、画面流畅度以及
硬件资源利用等方面达到平衡。游戏的逻辑层承担着处理玩家操作指令、进行物理碰撞检测以及实现 
AI 决策等关键任务。为了保证游戏状态的一致性和可预测性，逻辑层通常会采用固定帧率运行，比
如每秒 10 到 60 帧。这样一来，所有客户端都能以相同的节奏推进游戏逻辑，从而有效避免因网
络延迟或者硬件性能差异而导致的游戏不同步现象。以帧同步游戏为例，客户端会严格依据逻辑帧来
更新游戏状态，即便渲染帧率有所波动，也不会对游戏的核心逻辑造成影响。

渲染层的主要职责是生成游戏画面，其帧率会受到显卡性能和显示器刷新率的直接影响。如果强制让
渲染层和逻辑层保持相同的帧率，可能会出现以下问题：一方面，当显卡性能不足时，渲染速度会跟
不上逻辑更新的节奏，进而导致画面卡顿；另一方面，对于高刷新率的显示器来说，如果逻辑层帧率
较低，就会造成硬件资源的浪费。将渲染层独立出来，它就可以根据硬件的实际性能动态调整帧率，
例如在性能强劲的设备上达到 240 帧，从而为玩家呈现出更加流畅的画面。

逻辑层和渲染层对硬件资源的需求有所不同。逻辑层主要依赖 CPU 的计算能力，而渲染层则更依赖 
GPU 的图形处理能力。通过让两者以不同的帧率运行，能够使 CPU 和 GPU 分别承担不同的任务，
避免资源竞争。这样做可以让逻辑层专注于处理复杂的游戏逻辑，而渲染层则专注于优化画面质量，
从而提升游戏的整体运行效率。

不同的游戏类型对帧率的需求也各不相同。例如，RTS 游戏需要较高的逻辑帧率来保证单位操作的
精准性，而 MOBA 游戏则更注重渲染帧率带来的画面流畅感。通过分离逻辑层和渲染层的帧率，游
戏可以更好地适应不同的硬件配置和网络环境。在硬件性能较弱的设备上，渲染层可以适当降低帧
率，以保证逻辑层的稳定运行；在网络延迟较高的情况下，逻辑层可以通过补帧机制来减少画面的卡
顿现象。

网络延迟可能会导致逻辑帧的传输出现波动，而硬件性能的差异也会影响渲染的效率。将逻辑层和渲
染层分离后，逻辑层可以通过固定帧率来降低对网络延迟的敏感度，而渲染层则可以通过动态帧率来
适应不同的硬件性能。例如，当网络延迟较高时，逻辑层可以暂时缓存操作指令，等待网络恢复正常
后再进行处理；当硬件性能不足时，渲染层可以降低画面的分辨率或者特效等级，以保证游戏的流畅
运行。


